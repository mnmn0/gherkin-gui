import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';
import { GherkinParser } from '../../main/services/GherkinParser';
import { FileManagerService } from '../../main/services/FileManagerService';

// Use real file system for integration tests
describe.skip('File Operations Integration', () => {
  let fileManager: FileManagerService;
  let parser: GherkinParser;
  let tempDir: string;

  beforeAll(async () => {
    // Create a temporary directory for testing
    tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'gherkin-gui-test-'));

    fileManager = new FileManagerService();
    parser = new GherkinParser();
  });

  afterAll(async () => {
    // Clean up temporary directory
    if (fs.existsSync(tempDir)) {
      fs.rmSync(tempDir, { recursive: true, force: true });
    }
  });

  it('should create, read, and parse Gherkin files', async () => {
    const specContent = `Feature: User Authentication
  As a user
  I want to authenticate
  So that I can access the system

  Scenario: Valid login
    Given I am on the login page
    When I enter valid credentials
    Then I should be logged in`;

    const specPath = path.join(tempDir, 'auth.feature');

    // Create the file
    await fileManager.saveSpecification(specPath, specContent);

    // Verify file exists
    expect(fs.existsSync(specPath)).toBe(true);

    // Read the file back
    const readContent = await fileManager.loadSpecification(specPath);
    expect(readContent).toBe(specContent);

    // Parse the content
    const parsed = await parser.parse(readContent);
    expect(parsed.feature.name).toBe('User Authentication');
    expect(parsed.feature.scenarios).toHaveLength(1);
    expect(parsed.feature.scenarios[0].name).toBe('Valid login');
    expect(parsed.feature.scenarios[0].steps).toHaveLength(3);
  });

  it('should list specifications from directory', async () => {
    // Create multiple specification files
    const specs = [
      {
        name: 'login.feature',
        content:
          'Feature: Login\n  Scenario: Login test\n    Given I am logged in',
      },
      {
        name: 'signup.feature',
        content:
          'Feature: Signup\n  Scenario: Signup test\n    Given I am on signup page',
      },
      {
        name: 'profile.feature',
        content:
          'Feature: Profile\n  Scenario: View profile\n    Given I have a profile',
      },
    ];

    // Create specs directory
    const specsDir = path.join(tempDir, '.gherkin', 'spec');
    fs.mkdirSync(specsDir, { recursive: true });

    // Write specification files
    for (const spec of specs) {
      const specPath = path.join(specsDir, spec.name);
      await fileManager.saveSpecification(specPath, spec.content);
    }

    // Set the project path for the file manager
    await fileManager.initializeProject(tempDir);

    // List specifications
    const specList = await fileManager.listSpecifications();

    expect(specList).toHaveLength(3);
    expect(specList.map((s) => s.name).sort()).toEqual([
      'login.feature',
      'profile.feature',
      'signup.feature',
    ]);

    // Verify each specification can be parsed
    for (const spec of specList) {
      const content = await fileManager.loadSpecification(spec.filePath);
      const parsed = await parser.parse(content);
      expect(parsed.feature.name).toBeDefined();
      expect(parsed.feature.scenarios).toHaveLength(1);
    }
  });

  it('should handle file watching and change detection', async () => {
    const specPath = path.join(tempDir, 'watched.feature');
    const initialContent =
      'Feature: Initial\n  Scenario: Test\n    Given initial state';

    // Create initial file
    await fileManager.saveSpecification(specPath, initialContent);

    // Start watching
    const changePromise = new Promise<string>((resolve) => {
      fileManager.on('file-changed', (filePath: string) => {
        resolve(filePath);
      });
    });

    // Modify the file
    const updatedContent =
      'Feature: Updated\n  Scenario: Test\n    Given updated state';
    await fileManager.saveSpecification(specPath, updatedContent);

    // Wait for change detection (with timeout)
    const changedFile = await Promise.race([
      changePromise,
      new Promise<string>((_, reject) =>
        setTimeout(
          () => reject(new Error('Timeout waiting for file change')),
          2000,
        ),
      ),
    ]);

    expect(changedFile).toBe(specPath);

    // Verify content was updated
    const readContent = await fileManager.loadSpecification(specPath);
    expect(readContent).toBe(updatedContent);
  });

  it('should create backup files on save', async () => {
    const specPath = path.join(tempDir, 'backup-test.feature');
    const originalContent =
      'Feature: Original\n  Scenario: Test\n    Given original content';

    // Create initial file
    await fileManager.saveSpecification(specPath, originalContent);

    // Update the file (should create backup)
    const updatedContent =
      'Feature: Updated\n  Scenario: Test\n    Given updated content';
    await fileManager.saveSpecification(specPath, updatedContent);

    // Check if backup was created
    const backupDir = path.join(path.dirname(specPath), '.backup');

    if (fs.existsSync(backupDir)) {
      const backupFiles = fs
        .readdirSync(backupDir)
        .filter(
          (file) =>
            file.startsWith('backup-test.feature.') && file.endsWith('.bak'),
        );

      expect(backupFiles.length).toBeGreaterThan(0);

      // Verify backup contains original content
      const backupPath = path.join(backupDir, backupFiles[0]);
      const backupContent = fs.readFileSync(backupPath, 'utf-8');
      expect(backupContent).toBe(originalContent);
    }
  });

  it('should handle concurrent file operations', async () => {
    const numFiles = 10;
    const baseDir = path.join(tempDir, 'concurrent');
    fs.mkdirSync(baseDir, { recursive: true });

    // Create multiple files concurrently
    const createPromises = Array.from({ length: numFiles }, (_, i) => {
      const filePath = path.join(baseDir, `concurrent-${i}.feature`);
      const content = `Feature: Concurrent Test ${i}
  Scenario: Test scenario ${i}
    Given concurrent operation ${i}
    When I perform action ${i}
    Then I should see result ${i}`;

      return fileManager.saveSpecification(filePath, content);
    });

    await Promise.all(createPromises);

    // Verify all files were created
    const files = fs.readdirSync(baseDir).filter((f) => f.endsWith('.feature'));
    expect(files).toHaveLength(numFiles);

    // Read and parse all files concurrently
    const readPromises = files.map(async (fileName) => {
      const filePath = path.join(baseDir, fileName);
      const content = await fileManager.loadSpecification(filePath);
      const parsed = await parser.parse(content);

      return {
        fileName,
        feature: parsed.feature.name,
        scenarioCount: parsed.feature.scenarios.length,
      };
    });

    const results = await Promise.all(readPromises);

    expect(results).toHaveLength(numFiles);
    results.forEach((result, index) => {
      expect(result.fileName).toBe(`concurrent-${index}.feature`);
      expect(result.feature).toBe(`Concurrent Test ${index}`);
      expect(result.scenarioCount).toBe(1);
    });
  });

  it('should handle invalid Gherkin gracefully', async () => {
    const invalidContent = `This is not valid Gherkin content
    Random text without proper structure
    No feature keyword or scenarios`;

    const specPath = path.join(tempDir, 'invalid.feature');
    await fileManager.saveSpecification(specPath, invalidContent);

    // Parser should throw or return error information
    try {
      await parser.parse(invalidContent);
      fail('Parser should have thrown an error for invalid Gherkin');
    } catch (error) {
      expect(error).toBeDefined();
      expect(error.message || error).toContain('Feature');
    }
  });
});
